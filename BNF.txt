Note: there may be some features from the Engineering Notebook that I forgot to add in here.

Where <type> is a valid data type (primitive type, object, struct, enum, etc.)

(When I say "where <identifier> is a valid xxx name", I mean that the xxx exists,
something else does not already have its name, etc.)

---------STATEMENTS

<endchar> ::= "\n" | ";" | "\0"

<statement> ::= <var-stmt>
              | <member-stmt>
              | <if-stmt>
              | <for-loop>
              | <while-loop>
              | <function>
              | <return-stmt>
              | <class>
              | <namespace>
              | <use-stmt>
              | <directive>

                <endchar>

<preprocessor-directive> ::= "-" (<macro>
                                | <error>
                                | <if-dir>
                                | <ifdef>
                                | <ifndef>
                                | <access>
                                | <use>
                                | <setline>
                                | <emptydir>
                                | <undef>)

                             <endchar>

<class-stmts> ::= ( <indent-whitespace>  ( <member-stmt>
                                         | <access-mod>? <function>
                                         | ("declare") <access-mod>? <func-decl-contents>) )*

    (where the class is abstract if the keyword "abstract" comes before <function>)

<indented-statement> ::= <indent-whitespace> <statement>

<indent-whitespace> ::= (" " || "\t")+

    (where the amount of whitespace is greater than before the line that starts the block)

<var-stmt> ::= <var-decl-only> | <var-decl-assign>

<member-stmt> ::= <member-decl-only> | <member-decl-assign>

<block-stmts> ::= ":" <statement>
                  | ":" "\n" <indented-statement>+

<namespace> ::= "namespace" <identifier> <block-stmts>

    (where <identifier> is a valid namespace name)

<use-stmt> ::= "use" <identifier> ("." <identifier>)*

    (where the first <identifier> is a valid user made type,
     where the expression in parenthesis only exists if the first <identifier> was a namespace
        and if the second <identifier> is a member of the previous <identifier>)

---------VARIABLES

<identifier> ::= ("@")?2 [A-Za-z_] [A-Za-z_0-9]*

    (where the "@" sign is only present if the identifier is a member)

---------DECLARATIONS

<var-decl-contents> ::= (<identifier> ":" <type>) | (<identifier> ":" <type> "[" "]" ("of" <positive-integer>))?

    (where <identifier> is a valid variable name)

<var-decl-only> ::= "declare" <var-decl-contents>

<var-decl-assign> ::= "init" (<class-name> | <struct-name>) <identifier> "(" (value ("," value))? ")"

             | <var-decl-content> ("=" <value>)?

    (where <value> is of type <type>,
     where <positive-integer> is a positive integer)

<member-decl-contents> ::= <access-mod>? <identifier> ":" <type>

    (where <identifier> is a valid member name)

<member-decl-only> ::= "declare" <member-decl-contents>

<member-decl-assign> ::= <member-decl-contents> ("=" <value>)?

    (where <value> is of type <type>)

<func-decl-contents> ::= ("override")? "func " <identifier> "(" ( (<identifier> ":")? <type> ("," (<identifier> ":")? <type>)* )? ")" ("->" <type>)?

    (where <identifier> is a valid function name,
     where "override" is only there if the function overrides one in the superclass)

<func-decl-only> ::= "declare" <func-decl-contents>

---------CONTROL

<if-stmt> ::= "if " <boolean-value> <block-stmts>
              ("orif " <boolean-value> <block-stmts>)*
              ("else" <block-stmts>)?

<for-loop> ::= "for " <identifier> ":" <type> " from " <numeric-value> " to " <numeric-value> <block-stmts>
             | "for " <identifier> ":" <type> " in " (<string-value> | <list-value>) <block-stmts>

    (where <list-value> is a valid variable of a list type)

<while-loop> ::= "while " <boolean-value> <block-stmts>

<function> ::= <func-decl-contents> (<block-stmts>)?

<return-stmt> ::= "return" <value>

    (where <value> is of the return type of the function)

<class-declaration> ::= ("generic")? "class " <identifier> (("is_a" | "is_an") <access-mod>? <superclass>) <class-stmts>

    (where <superclass> is the superclass of the object,
     where <identifier> is a valid class name)

---------VALUES

NUMBERS:
    <numeric-value> ::= "(" <numeric-value> ")"
                      | <numeric-expression>
                      | <number-literal>
                      | <numeric-variable>

        (where <numeric-variable> is a variable of a numeric type)

    <number-literal> ::= ("-")? [0-9]+ ("."? [0-9]+)

    <numeric-expression> ::= <numeric-value> <binary-arithmetic-operator> <numeric-value>
                           | <unary-prefix-arithmetic-operator> <numeric-value>
                           | <numeric-value> <unary-postfix-arithmetic-operator>

    <unary-prefix-arithmetic-operator> ::= "++" | "--"

    <unary-postfix-arithmetic-operator> ::= "++" | "--"

    <binary-arithmetic-operator> ::= "+" | "-" | "*" | "/" | "%" | "^" |
                                     ">" | "<" | ">=" | "<=" |
                                     "+=" | "-=" | "*=" | "/=" | "%=" | "^="

BOOLEANS:
    <boolean-value> ::= <boolean-literal>
                      | <boolean-expression>
                      | <boolean-variable>

        (where <boolean-variable> is a variable of a boolean type)

    <boolean-literal> ::= "true" | "false"

    <boolean-expression> ::= <unary-boolean-prefix-operator> <boolean-value>
                           | <boolean-value> <binary-boolean-operator> <boolean-value>

    <unary-boolean-prefix-operator> ::= "not"

    <binary-boolean-operator> ::= "and" | "or"

STRINGS:
    <string-value> ::= "\"" <any-characters>* ( (?<!"\\") "\"")
                     | <string-variable>

        (where <string-variable> is a variable of a string type)

MEMORY:
    <pointer> ::= "Pointer" ":" <type>
                | "WeakSingle" ":" <type>
                | "Single" ":" <type>
                | <pointer-variable>

        (where <pointer-variable> is a variable of a pointer type)

    <reference> ::= "Ref" ":" <type>
                  | <reference-variable>

        (where <reference-variable> is a variable of type reference)

    <memory-value> ::= <pointer> | <reference>

FUNCTIONS/METHODS:
    <call> ::= <identifier> "(" ( <identifier ("," <identifier>)* )? ")"

VALUES:
<value> ::= <numeric-value>
          | <boolean-value>
          | <memory-value>
          | <string-value>
          | <call>

          | <value> <binary-value-operator> <value>

          ("as" <type>)?

    (where <positive-integer> is a positive integer,
     where <type> is a valid type that you can cast the value to)

<binary-value-operator> ::= "is" | "!="

---------PREPROCESSOR DIRECTIVES

(where <filename> is a valid filename on user's operating system)

<macro> ::= "macro" <identifier>
            "(" (("|" <identifier> "|") | <identifier>) ("," ("|" <identifier> "|") | <identifier>))*)? ")"
            ( ("|" <any-characters> "|") | <value>) )

    (where <identifier> is a valid macro name)

<error> ::= "error" <value> | ("|" <any-characters> "|")

<if-dir> ::= "if" <boolean-value> <block-stmts>
             ("@" "orif" <boolean-value> <block-stmts>)*
             ("@" "else" <block-stmts>)?

<ifdef> ::= "ifdefined" <identifier> <block-stmts>

<ifndef> ::= "ifnotdefined" <identifier> <block-stmts>

<undef> ::= "undefine" <identifier>

<access> ::= "access" <filename>

<use> ::= "use" ( <filename> ( <filename> "\n")* )?

<setline> ::= "setline" <numeric-value> (<filename>)

<empty> ::= ""

---------MISCELLANEOUS

<object-member-access> ::= <object-variable> "." <member>
                         | <object-pointer-variable> "->" <member>

    (where <object-variable> is a variable of an object type
     where <object-pointer-variable> is a pointer to an object
     where <member> is either a property of the object or a <call> on a method in the object with the appropriate arguments)

<access-mod> ::= "visible" | "hidden" | "inherited"

